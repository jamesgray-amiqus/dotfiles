#!/usr/bin/env bash
# This script was generated by bashly 1.3.6 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dotfiles_usage() {
  printf "dotfiles - dotfiles\n\n"

  printf "%s\n" "Usage:"
  printf "  dotfiles COMMAND\n"
  printf "  dotfiles [COMMAND] --help | -h\n"
  printf "  dotfiles --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   clone github repositories\n" "clone    "
  printf "  %s   provision\n" "provision"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "GIT_USER_NAME"
    printf "    Set your GIT username\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "GIT_USER_EMAIL"
    printf "    Set your Git email\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "GITHUB_USER_NAME"
    printf "    Set your GITHUB username\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "GITHUB_ORG"
    printf "    Set your GITHUB_ORG username\n"
    echo

  fi
}

# :command.usage
dotfiles_clone_usage() {
  printf "dotfiles clone - clone github repositories\n\n"

  printf "%s\n" "Usage:"
  printf "  dotfiles clone\n"
  printf "  dotfiles clone --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotfiles_provision_usage() {
  printf "dotfiles provision - provision\n\n"

  printf "%s\n" "Usage:"
  printf "  dotfiles provision\n"
  printf "  dotfiles provision --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
dotfiles_clone_command() {

  # src/clone_command.sh
  if [ -f "$HOME/.envrc" ]; then
      source "$HOME/.envrc"
  else
      echo "ERROR: ~/.envrc not found. Please create it with your env variables."
      exit 1
  fi

  : "${GITHUB_USERNAME:?GITHUB_USERNAME must be set in ~/.envrc}"
  : "${GITHUB_ORG:?GITHUB_ORG must be set in ~/.envrc}"
  : "${PROJECTS_DIR:?PROJECTS_DIR must be set in ~/.envrc}"
  : "${GIT_USER_NAME:?GIT_USER_NAME must be set in ~/.envrc}"
  : "${GIT_USER_EMAIL:?GIT_USER_EMAIL must be set in ~/.envrc}"

  mkdir -p "$PROJECTS_DIR"

  log() { printf "\n==> %s\n" "$*"; }

  configure_gh_cli() {
      log "Configuring GitHub CLI..."
      if gh auth status >/dev/null 2>&1; then
          log "Already logged in"
      else
          log "Logging in via web..."
          gh auth login --web
      fi

      gh config set git_protocol ssh
      gh config set editor "zed"
  }

  configure_github_ssh() {
      log "Configuring GitHub SSH key..."
      local ssh_file="$HOME/.ssh/id_github"
      if [ -f "$ssh_file" ]; then
          log "SSH key already exists: $ssh_file"
      else
          ssh-keygen -t ed25519 -C "$GIT_USER_EMAIL" -f "$ssh_file" -N "" || true
          eval "$(ssh-agent -s)" >/dev/null 2>&1 || true
          ssh-add "$ssh_file" >/dev/null 2>&1 || true
          pbcopy < "${ssh_file}.pub"
          log "SSH public key copied to clipboard. Add it to GitHub: https://github.com/settings/new"
      fi
  }

  configure_git_gpg() {
      log "Configuring GPG for signed commits..."
      have_gpg=$(command -v gpg || true)
      [ -z "$have_gpg" ] && { log "GPG not installed, skipping"; return; }

      local key_id
      key_id="$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | awk '/sec/{print $2}' | cut -d/ -f2 | head -n1 || true)"

      if [ -z "$key_id" ]; then
          log "No GPG key found â€” generating one"
          cat > /tmp/gpg-batch <<EOF
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: $GIT_USER_NAME
Name-Email: $GIT_USER_EMAIL
Expire-Date: 0
%no-protection
%commit
EOF
          gpg --batch --generate-key /tmp/gpg-batch || true
          rm -f /tmp/gpg-batch
          key_id="$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | awk '/sec/{print $2}' | cut -d/ -f2 | head -n1 || true)"
      fi

      [ -z "$key_id" ] && return

      git config --global user.signingkey "$key_id"
      git config --global commit.gpgsign true
      git config --global gpg.program gpg
      log "Using GPG key: $key_id"

      git config --global alias.co checkout
      git config --global alias.br branch
      git config --global alias.ci commit
      git config --global alias.st status

      if gh auth status >/dev/null 2>&1; then
          printf "%s\n" "$(gpg --armor --export "$key_id")" | gh gpg-key add - || true
          log "Uploaded GPG key to GitHub"
      else
          log "Open GitHub GPG key page to add key manually"
          open "https://github.com/settings/keys/gpg/new"
      fi
  }

  clone_github_repos() {
      log "Cloning repositories into $PROJECTS_DIR..."

      clone_repos_from() {
          local owner="$1"
          local repos
          repos=$(gh repo list "$owner" --limit 1000 --json nameWithOwner -q '.[].nameWithOwner')
          for repo in $repos; do
              log "Cloning $repo..."
              local dir="$PROJECTS_DIR/$(basename "$repo")"
              if [ -d "$dir/.git" ]; then
                  log "Already cloned: $repo"
              else
                  gh repo clone "$repo" "$dir" || log "Failed to clone: $repo"
              fi
          done
      }

      clone_repos_from "$GITHUB_USERNAME"
      clone_repos_from "$GITHUB_ORG"
  }

  main() {
      log "Starting GitHub setup + repo cloning"
      configure_gh_cli
      configure_github_ssh
      configure_git_gpg
      clone_github_repos
      log "GitHub setup and cloning complete!"
  }

  main "$@"

}

# :command.function
dotfiles_provision_command() {

  # src/provision_command.sh
  if [ -f "$HOME/.envrc" ]; then
      # shellcheck disable=SC1090
      source "$HOME/.envrc"
  else
      echo "ERROR: ~/.envrc not found. Please create it with your env variables."
      exit 1
  fi

  : "${PROJECTS_DIR:?PROJECTS_DIR must be set in ~/.envrc}"

  log() { printf "\n==> %s\n" "$*"; }
  have_cmd() { command -v "$1" >/dev/null 2>&1; }
  try() { "$@" || log "Non-fatal failure: $*"; }

  brew_shellenv() {
      if [ -x "/opt/homebrew/bin/brew" ]; then
          eval "$(/opt/homebrew/bin/brew shellenv)"
      elif [ -x "/usr/local/bin/brew" ]; then
          eval "$(/usr/local/bin/brew shellenv)"
      fi
  }

  ensure_homebrew() {
      if have_cmd brew; then
          log "Homebrew already installed"
          brew_shellenv
          return
      fi
      log "Installing Homebrew"
      NONINTERACTIVE=1 /bin/bash -c \
          "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" \
          || log "Homebrew install failed; continuing"
      brew_shellenv
  }

  brew_install_formula() {
      local pkg="$1"
      if brew list --formula "$pkg" >/dev/null 2>&1; then
          log "Formula already installed: $pkg"
      else
          log "Installing formula: $pkg"
          try brew install "$pkg"
      fi
  }

  brew_install_cask() {
      local cask="$1"
      if brew list --cask "$cask" >/dev/null 2>&1; then
          log "Cask already installed: $cask"
      else
          log "Installing cask: $cask"
          try brew install --cask "$cask"
      fi
  }

  jamf_self_elevate() {
      [ "${SKIP_JAMF_ELEVATE:-0}" = "1" ] && return
      local jamf_bin=""
      [ -x "/usr/local/bin/jamf" ] && jamf_bin="/usr/local/bin/jamf"
      [ -x "/usr/bin/jamf" ] && jamf_bin="/usr/bin/jamf"
      [ -z "$jamf_bin" ] && return
      [ -z "${JAMF_ELEVATE_TRIGGER:-}" ] && return
      log "Attempting Jamf elevation"
      sudo "$jamf_bin" policy -event "$JAMF_ELEVATE_TRIGGER" || true
  }

  install_packages() {
      log "Updating Homebrew"
      brew update || true

      local cli=(git gnupg gh starship fzf htop wget curl jq bat ripgrep fd tree tldr httpie tmux watch ncdu git-delta the_silver_searcher pyenv tfenv zoxide)
      for pkg in "${cli[@]}"; do
          brew_install_formula "$pkg"
      done

      local apps=(docker iterm2 firefox clipy flux 1password-cli tomatobar)
      for app in "${apps[@]}"; do
          brew_install_cask "$app"
      done

      if ! brew list --formula flux >/dev/null 2>&1; then
          log "Installing FluxCD CLI"
          try brew tap fluxcd/tap
          try brew install fluxcd/tap/flux
      fi

      local fonts=(font-fira-code-nerd-font font-jetbrains-mono-nerd-font font-hack-nerd-font)
      for f in "${fonts[@]}"; do
          brew_install_cask "$f"
      done

      local fzf_install_path
      fzf_install_path="$(brew --prefix)/opt/fzf/install"
      [ -x "$fzf_install_path" ] && yes | "$fzf_install_path" --all

      brew upgrade || true
      brew cleanup || true
  }

  configure_zsh() {
      log "Configuring Zsh environment"
      touch "$HOME/.zshrc"
      cat <<EOF > "$HOME/.zshrc"
source "$PROJECTS_DIR/dotfiles/dotfiles.zsh"
EOF
  }

  apply_ui_tweaks() {
      log "Applying macOS UI tweaks"

      defaults delete com.apple.dock autohide 2>/dev/null || true
      defaults delete com.apple.dock autohide-delay 2>/dev/null || true
      defaults delete com.apple.dock autohide-time-modifier 2>/dev/null || true
      defaults delete com.apple.dock mineffect 2>/dev/null || true
      defaults delete com.apple.dock launchanim 2>/dev/null || true
      defaults delete com.apple.dock expose-animation-duration 2>/dev/null || true
      defaults write NSGlobalDomain AppleShowAllExtensions -bool true
      defaults write com.apple.finder ShowStatusBar -bool true
      defaults write com.apple.finder ShowPathbar -bool true
      killall Dock Finder

      defaults write NSGlobalDomain KeyRepeat -int "${KEY_REPEAT:-1}"
      defaults write NSGlobalDomain InitialKeyRepeat -int "${INITIAL_KEY_REPEAT:-10}"

      sudo defaults write com.apple.universalaccess reduceMotion -bool true || true
      sudo defaults write com.apple.universalaccess reduceTransparency -bool true || true

      defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad Clicking -bool true
      defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad TrackpadThreeFingerDrag -bool true
      defaults write NSGlobalDomain com.apple.swipescrolldirection -bool false
      defaults write NSGlobalDomain com.apple.mouse.scaling -float 3.0

      mkdir -p "$HOME/Screenshots"
      defaults write com.apple.screencapture location -string "$HOME/Screenshots"
      defaults write com.apple.screencapture disable-shadow -bool true
      killall SystemUIServer

      sudo mdutil -i on / >/dev/null 2>&1 || true
      sudo mdutil -E / >/dev/null 2>&1 || true
  }

  configure_iterm2() {
      log "Configuring iTerm2"

      local plist="$HOME/Library/Preferences/com.googlecode.iterm2.plist"
      [ ! -f "$plist" ] && { open -a iTerm; sleep 5; killall iTerm >/dev/null 2>&1; }

      defaults write com.googlecode.iterm2 "UseDarkColorPalette" -bool false
      defaults write com.googlecode.iterm2 "SilenceBell" -bool true
      defaults write com.googlecode.iterm2 "UnlimitedScrollback" -bool true
      defaults write com.googlecode.iterm2 "ScrollbackLines" -int 1000000

      local default_uuid
      default_uuid=$(defaults read com.googlecode.iterm2 "Default Bookmark Guid" 2>/dev/null)
      [ -n "$default_uuid" ] && /usr/libexec/PlistBuddy -c "Set :'New Bookmarks':0:'Normal Font' 'Fira Code Nerd Font 14'" "$plist" 2>/dev/null || true
  }

  set_default_apps() {
      log "Setting default terminal and browser"
      have_cmd duti || brew install duti
      duti -s com.googlecode.iterm2 public.shell-script all
      duti -s com.google.Chrome http
      duti -s com.google.Chrome https
      duti -s com.google.Chrome public.html
  }

  install_rbenv() { rbenv install 3.4.8 && rbenv global 3.4.8 || true; }
  install_tfenv() { tfenv install 1.14.3 && tfenv use 1.14.3 || true; }

  main() {
      log "Starting macOS developer provisioning"
      jamf_self_elevate
      ensure_homebrew
      install_packages
      configure_zsh
      apply_ui_tweaks
      configure_iterm2
      set_default_apps
      install_rbenv
      install_tfenv
      log "Provisioning complete. Some changes may require logout/login."
  }

  main "$@"

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dotfiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("GIT_USER_NAME")
  env_var_names+=("GIT_USER_EMAIL")
  env_var_names+=("GITHUB_USER_NAME")
  env_var_names+=("GITHUB_ORG")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    clone)
      action="clone"
      shift
      dotfiles_clone_parse_requirements "$@"
      shift $#
      ;;

    provision)
      action="provision"
      shift
      dotfiles_provision_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      dotfiles_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotfiles_clone_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        dotfiles_clone_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clone"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotfiles_provision_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        dotfiles_provision_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="provision"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "clone") dotfiles_clone_command ;;
    "provision") dotfiles_provision_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
