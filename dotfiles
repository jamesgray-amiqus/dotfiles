#!/usr/bin/env bash
# This script was generated by bashly 1.3.6 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dotfiles_usage() {
  printf "dotfiles - dotfiles\n\n"

  printf "%s\n" "Usage:"
  printf "  dotfiles COMMAND\n"
  printf "  dotfiles [COMMAND] --help | -h\n"
  printf "  dotfiles --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   setup and clone github repositories\n" "github   "
  printf "  %s   provision\n" "provision"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dotfiles_github_usage() {
  printf "dotfiles github - setup and clone github repositories\n\n"

  printf "%s\n" "Usage:"
  printf "  dotfiles github\n"
  printf "  dotfiles github --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotfiles_provision_usage() {
  printf "dotfiles provision - provision\n\n"

  printf "%s\n" "Usage:"
  printf "  dotfiles provision\n"
  printf "  dotfiles provision --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
dotfiles_github_command() {

  # src/github_command.sh
  # ----------------------------------------
  # Source env and check required variables
  # ----------------------------------------
  if [ -f "$HOME/.envrc" ]; then
    source "$HOME/.envrc"
  else
    cp ./.envrc.sample "$HOME"
    echo "ERROR: ~/.envrc not found. Please create it with your env variables."
    exit 1
  fi

  : "${GITHUB_USERNAME:?GITHUB_USERNAME must be set in ~/.envrc}"
  : "${GITHUB_ORG:?GITHUB_ORG must be set in ~/.envrc}"
  : "${PROJECTS_DIR:?PROJECTS_DIR must be set in ~/.envrc}"
  : "${GIT_USER_NAME:?GIT_USER_NAME must be set in ~/.envrc}"
  : "${GIT_USER_EMAIL:?GIT_USER_EMAIL must be set in ~/.envrc}"

  mkdir -p "$PROJECTS_DIR"

  log() { printf "\n==> %s\n" "$*"; }

  # ----------------------------------------
  # GitHub CLI configuration
  # ----------------------------------------
  configure_gh_cli() {
    log "Configuring GitHub CLI..."
    if gh auth status >/dev/null 2>&1; then
      log "Already logged in"
    else
      log "Logging in via web..."
      gh auth login --web
    fi

    gh config set git_protocol ssh
    gh config set editor "zed"
  }

  # ----------------------------------------
  # GitHub SSH key setup
  # ----------------------------------------
  configure_github_ssh() {
    log "Configuring GitHub SSH key..."
    local ssh_file="$HOME/.ssh/id_github"
    if [ -f "$ssh_file" ]; then
      log "SSH key already exists: $ssh_file"
    else
      ssh-keygen -t ed25519 -C "$GIT_USER_EMAIL" -f "$ssh_file" -N "" || true
      eval "$(ssh-agent -s)" >/dev/null 2>&1 || true
      ssh-add "$ssh_file" >/dev/null 2>&1 || true
      pbcopy <"${ssh_file}.pub"
      log "SSH public key copied to clipboard. Add it to GitHub: https://github.com/settings/new"
    fi
  }

  # ----------------------------------------
  # Configure GPG for signed commits
  # ----------------------------------------
  configure_git_gpg() {
    log "Configuring GPG for signed commits..."
    have_gpg=$(command -v gpg || true)
    [ -z "$have_gpg" ] && {
      log "GPG not installed, skipping"
      return
    }

    local key_id
    key_id="$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | awk '/sec/{print $2}' | cut -d/ -f2 | head -n1 || true)"

    if [ -z "$key_id" ]; then
      log "No GPG key found — generating one"
      cat >/tmp/gpg-batch <<EOF
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: $GIT_USER_NAME
Name-Email: $GIT_USER_EMAIL
Expire-Date: 0
%no-protection
%commit
EOF
      gpg --batch --generate-key /tmp/gpg-batch || true
      rm -f /tmp/gpg-batch
      key_id="$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | awk '/sec/{print $2}' | cut -d/ -f2 | head -n1 || true)"
    fi

    [ -z "$key_id" ] && return

    git config --global user.signingkey "$key_id"
    git config --global commit.gpgsign true
    git config --global gpg.program gpg
    log "Using GPG key: $key_id"

    git config --global alias.co checkout
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.br 'branch --all'
    git config --global alias.lg "log --oneline --graph --all --decorate"

    if gh auth status >/dev/null 2>&1; then
      printf "%s\n" "$(gpg --armor --export "$key_id")" | gh gpg-key add - || true
      log "Uploaded GPG key to GitHub"
    else
      log "Open GitHub GPG key page to add key manually"
      open "https://github.com/settings/keys/gpg/new"
    fi
  }

  update_repo() {
    local repo_dir="$1"
    [ -d "$repo_dir/.git" ] || return

    log "Updating $(basename "$repo_dir")..."
    pushd "$repo_dir" >/dev/null || return

    # Fetch all remotes
    git fetch --all --prune

    # Determine default branch (main or master)
    default_branch=$(git remote show origin | awk '/HEAD branch/ {print $NF}')

    # Switch to default branch and pull latest changes
    git checkout "$default_branch"
    git pull origin "$default_branch"

    popd >/dev/null || return
  }

  # ----------------------------------------
  # Pull all branches for a given repository
  # ----------------------------------------
  pull_all_branches() {
    local repo_dir="$1"
    [ -d "$repo_dir/.git" ] || return

    log "Pulling all branches for $(basename "$repo_dir")..."
    pushd "$repo_dir" >/dev/null || return

    git fetch --all

    # Loop over remote branches
    for branch in $(git branch -r | grep -v '\->' | sed 's|origin/||'); do
      git branch --track "$branch" "origin/$branch" 2>/dev/null || true
      git checkout "$branch"
      git pull
    done

    # Return to previous directory
    git checkout main 2>/dev/null || git checkout master 2>/dev/null || true
    popd >/dev/null || return
  }

  # ----------------------------------------
  # Clone GitHub repos and pull all branches
  # ----------------------------------------
  clone_github_repos() {
    log "Cloning repositories into $PROJECTS_DIR..."

    clone_repos_from() {
      local owner="$1"
      local repos
      repos=$(gh repo list "$owner" --limit 1000 --json nameWithOwner -q '.[].nameWithOwner')

      for repo in $repos; do
        log "Processing $repo..."
        local dir="$PROJECTS_DIR/$(basename "$repo")"

        if [ -d "$dir/.git" ]; then
          log "Already cloned — updating default branch"
          update_repo "$dir"
        else
          gh repo clone "$repo" "$dir" || {
            log "Failed to clone: $repo"
            continue
          }
          update_repo "$dir"
        fi
      done
    }

    clone_repos_from "$GITHUB_USERNAME"
    clone_repos_from "$GITHUB_ORG"
  }

  # ----------------------------------------
  # Main
  # ----------------------------------------
  main() {
    log "Starting GitHub setup + repo cloning"
    configure_gh_cli
    configure_github_ssh
    configure_git_gpg
    clone_github_repos
    log "GitHub setup and cloning complete!"
  }

  main "$@"

}

# :command.function
dotfiles_provision_command() {

  # src/provision_command.sh
  #!/usr/bin/env bash
  set -uo pipefail

  # =================
  # Load environment
  # =================
  if [ -f "$HOME/.envrc" ]; then
    source "$HOME/.envrc"
  else
    echo "ERROR: ~/.envrc not found. Please create it with your env variables."
    exit 1
  fi

  : "${GITHUB_ORG:?GITHUB_ORG must be set in ~/.envrc}"
  : "${GITHUB_USERNAME:?GITHUB_USERNAME must be set in ~/.envrc}"
  : "${NODE_VERSION:?NODE_VERSION must be set in ~/.envrc}"
  : "${PROJECTS_DIR:?PROJECTS_DIR must be set in ~/.envrc}"
  : "${PYTHON_VERSION:?PYTHON_VERSION must be set in ~/.envrc}"
  : "${RUBY_VERSION:?RUBY_VERSION must be set in ~/.envrc}"
  : "${TF_VERSION:?TF_VERSION must be set in ~/.envrc}"

  mkdir -p "$PROJECTS_DIR"

  # =================
  # Helpers
  # =================
  log() { printf "\n==> %s\n" "$*"; }
  have_cmd() { command -v "$1" >/dev/null 2>&1; }
  try() { "$@" || log "Non-fatal failure: $*"; }

  brew_shellenv() {
    if [ -x "/opt/homebrew/bin/brew" ]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [ -x "/usr/local/bin/brew" ]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  }

  # =================
  # Homebrew
  # =================
  ensure_homebrew() {
    if have_cmd brew; then
      log "Homebrew already installed"
      brew_shellenv
      return
    fi
    log "Installing Homebrew"
    NONINTERACTIVE=1 /bin/bash -c \
      "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" ||
      log "Homebrew install failed; continuing"
    brew_shellenv
  }

  brew_install_formula() {
    local pkg="$1"
    if brew list --formula "$pkg" >/dev/null 2>&1; then
      log "Formula already installed: $pkg"
    else
      log "Installing formula: $pkg"
      try brew install "$pkg"
    fi
  }

  brew_install_cask() {
    local cask="$1"
    if brew list --cask "$cask" >/dev/null 2>&1; then
      log "Cask already installed: $cask"
    else
      log "Installing cask: $cask"
      try brew install --cask "$cask"
    fi
  }

  # =================
  # Packages / Apps
  # =================
  install_packages() {
    log "Updating Homebrew"
    brew update || true

    log "Upgrading Homebrew"
    brew upgrade || true

    local cli=(
      ack
      awscli
      bat
      ccal
      croc
      curl
      espanso
      fd
      fzf
      gh
      git
      git-branchless
      git-delta
      git-extras
      gnupg
      gum
      htop
      httpie
      jq
      lazygit
      ncdu
      nvm
      pyenv
      ripgrep
      shellcheck
      starship
      tfenv
      the_silver_searcher
      tig
      tldr
      tmux
      tree
      watch
      wget
      yamlfmt
      zoxide
    )
    for pkg in "${cli[@]}"; do brew_install_formula "$pkg"; done

    local apps=(
      1password-cli
      clipy
      docker
      firefox
      flux
      iterm2
      session-manager-plugin
      tomatobar
    )
    for app in "${apps[@]}"; do brew_install_cask "$app"; done

    # FluxCD CLI
    if ! brew list --formula flux >/dev/null 2>&1; then
      log "Installing FluxCD CLI"
      try brew tap fluxcd/tap
      try brew install fluxcd/tap/flux
    fi

    # Nerd Fonts
    local fonts=(font-fira-code-nerd-font font-jetbrains-mono-nerd-font font-hack-nerd-font)
    for f in "${fonts[@]}"; do brew_install_cask "$f"; done

    # fzf shell integration
    local fzf_install_path
    fzf_install_path="$(brew --prefix)/opt/fzf/install"
    [ -x "$fzf_install_path" ] && yes | "$fzf_install_path" --all

    brew upgrade || true
    brew cleanup || true
  }

  # =================
  # Zsh + env
  # =================
  configure_zsh() {
    log "Configuring Zsh environment"
    cat <<EOF >"$HOME/.zprofile"
eval "$(/opt/homebrew/bin/brew shellenv)"

if [ -f "$HOME/.zshrc" ]; then
  source "$HOME/.zshrc"
fi
EOF

    cat <<EOF >"$HOME/.zshrc"
source "$PROJECTS_DIR/$GITHUB_USERNAME/dotfiles/dotfiles.zsh"
EOF
  }

  # =================
  # iTerm2 config from exported JSON
  # =================
  configure_iterm2() {
    log "Configuring iTerm2 from exported JSON"

    local json_file="$PROJECTS_DIR/dotfiles/iterm2_profile.json"
    if [ -f "$json_file" ]; then
      log "Importing iTerm2 profile from JSON"
      open "$json_file" # iTerm will import it automatically
      sleep 3
    else
      log "No exported iTerm2 JSON found, skipping"
    fi
  }

  # =================
  # Ruby / Terraform / Node / Python
  # =================
  install_nvm() { nvm install "$NODE_VERSION" && nvm use "$NODE_VERSION" || true; }
  install_pyenv() { pyenv install "$PYTHON_VERSION" && pyenv global "$PYTHON_VERSION" || true
  install_rbenv() { rbenv install "$RUBY_VERSION" && rbenv global "$RUBY_VERSION" || true; }
  install_tfenv() { tfenv install "$TF_VERSION" && tfenv use "$TF_VERSION" || true; }

  # =================
  # Main
  # =================
  main() {
    log "Starting macOS developer provisioning"
    ensure_homebrew
    install_packages
    configure_zsh
    configure_iterm2
    install_nvm
    install_pyenv
    install_rbenv
    install_tfenv
    log "Provisioning complete. Open a new terminal tab to apply Zsh & iTerm2 settings."
  }

  main "$@"

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dotfiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    github)
      action="github"
      shift
      dotfiles_github_parse_requirements "$@"
      shift $#
      ;;

    provision)
      action="provision"
      shift
      dotfiles_provision_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      dotfiles_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotfiles_github_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        dotfiles_github_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="github"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotfiles_provision_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        dotfiles_provision_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="provision"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "github") dotfiles_github_command ;;
    "provision") dotfiles_provision_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
